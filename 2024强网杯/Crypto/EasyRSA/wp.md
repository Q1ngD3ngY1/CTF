# EasyRSA题解
```python
from Crypto.Util.number import bytes_to_long, long_to_bytes  
from gmpy2 import mpz, iroot, powmod, invert  
  
# 基本参数
mod_N = mpz("68536832659498002809312426931967043249669525229212185868487610856526209437541877406718087998428126254515505594274625464947318071175096963620269135916508912457889453158147902022377907510927465114276264176291340115481350463064364068938165228764998238325503256272547690811959461923347075540205353920264338503081746348998172207734066491320589070160663167994274645314566112918683082080554515469503992017916889964692441249677285741424740188126329309550469938464332070748229334277063819784631267431588868208613199421984254161143701088525618468757523983979965638839073522788337809469185794854765088129189851438560776402172127")  
g = mpz("2510710439030315412540499989728744805446953685354564631694928390256258553966937097420379663077589988387275086638976833559463300328132754254025781717349")  
exp_e = 65537  
cipher_enc = mpz("66039092638715463232627217107053199772520302726228609255582091679968271044660788488417709326428758407927296241219102506512319962028932708920399357876990954926002023203809094636768248889811765836003298985309323775693013414279269659194605197476779929177993585372420104885248004811148813400174435256471852136267631573673627911570655448292581494370402244791881387574007523394185123544241060367835319908018449483235502017984680925980414047201507061138537430020511176432889964410617686596615592204940726479593937535759601763690225664730006848948687327770853345353722527065392777452016705471192351596418597042965905282485170")  
  
def guess(start_r=5500, start_s=2000):  
    # 计算N的平方根  
    sqrt_modulus = iroot(mpz(mod_N), 2)[0]  
    approx_C = sqrt_modulus // (g * g)  

    base_a = 2  
    # 计算a的g次幂模N  
    base_b = powmod(base_a, g, mod_N)  
  
    for i in range(2, int(approx_C) + 1):  
        # 计算D  
        D = (iroot(approx_C, 2)[0] + 1) * i  
        # 计算b的u次幂模N  
        final_value = powmod(base_b, factor_a, mod_N)  
        for r in range(start_r, int(D)):  
            print(f"rD: {r * D}")  
            for s in range(start_s, int(D)):  
                if powmod(base_b, r * D + s, mod_N) == final_value:  
                    print("r =", r, "s =", s, "i =", i)  
                    return r * D + s  

# 计算辅助参数  
h = (mod_N - 1) // g  
factor_a = h // g  
modu_b = h % g  
salt = guess()  
  
# 计算p和q  
p = 2 * g * (((modu_b + salt * g) + iroot((modu_b + salt * g)**2 - 4 * (factor_a - salt), 2)[0]) // 2 // 2) + 1  
q = 2 * g * (((modu_b + salt * g) - iroot((modu_b + salt * g)**2 - 4 * (factor_a - salt), 2)[0]) // 2 // 2) + 1  
  
# 计算私钥d  
d = invert(exp_e, (p - 1) * (q - 1))  
  
m = powmod(cipher_enc, d, mod_N)  
print(long_to_bytes(m))

```