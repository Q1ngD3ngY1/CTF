# ezsign题解(DSA签名攻击+pq猜解)
## 解答
题目源码：
```python
from Crypto.Util.number import *
from gmpy2 import *
from hashlib import*
import random,os

flag = b'D0g3xGA{***************}'
msg = b'e = ?'

def sign(pub, pri, k):
    (p,q,g,y) = pub
    x = pri
    r = int(powmod(g, k, p) % q)
    H = bytes_to_long(sha1(os.urandom(20)).digest())
    s = int((H + r * x) * invert(k, q) % q)
    return (H,r,s)

k1 = getPrime(64)
k2 = k1 ** 2
pri = bytes_to_long(msg)
a = 149328490045436942604988875802116489621328828898285420947715311349436861817490291824444921097051302371708542907256342876547658101870212721747647670430302669064864905380294108258544172347364992433926644937979367545128905469215614628012983692577094048505556341118385280805187867314256525730071844236934151633203
b = 829396411171540475587755762866203184101195238207
g = 87036604306839610565326489540582721363203007549199721259441400754982765368067012246281187432501490614633302696667034188357108387643921907247964850741525797183732941221335215366182266284004953589251764575162228404140768536534167491117433689878845912406615227673100755350290475167413701005196853054828541680397
y = 97644672217092534422903769459190836176879315123054001151977789291649564201120414036287557280431608390741595834467632108397663276781265601024889217654490419259208919898180195586714790127650244788782155032615116944102113736041131315531765220891253274685646444667344472175149252120261958868249193192444916098238

pub = (a, b, g, y)

H1, r1, s1 = sign(pub, pri, k1)

H2, r2, s2 = sign(pub, pri, k2)

p = getPrime(128)
q = getPrime(128)
n = p * q
c = powmod(bytes_to_long(flag), e, n)

C = p**2 + q**2

print(f'(H1, r1, s1) = {H1}, {r1}, {s1}')
print(f'(H2, r2, s2) = {H2}, {r2}, {s2}')
print(c)
print(C)

'''
(H1, r1, s1) = 659787401883545685817457221852854226644541324571, 334878452864978819061930997065061937449464345411, 282119793273156214497433603026823910474682900640
(H2, r2, s2) = 156467414524100313878421798396433081456201599833, 584114556699509111695337565541829205336940360354, 827371522240921066790477048569787834877112159142
c = 18947793008364154366082991046877977562448549186943043756326365751169362247521
C = 179093209181929149953346613617854206675976823277412565868079070299728290913658
'''
```

看下源码，直接说思路：先是利用dsa攻击获取公钥e，然后再暴力猜解p和q。
参考链接：
> [DSA攻击原理](https://ctf-wiki.org/crypto/signature/dsa/)\
[DSA攻击集锦](https://hengxinyan.github.io/2023/08/10/Crypto%E7%B3%BB%E5%88%97--%5BDSA%5D/)\
[easy_factoring - zer0pts CTF 2023](https://connor-mccartney.github.io/cryptography/other/easy-factoring-zer0pts-CTF-2023)

获取公钥e脚本：
```python
from Crypto.Util.number import *
import gmpy2
import itertools
from libnum import *
# 定义变量
(h1, r1, s1) = (659787401883545685817457221852854226644541324571, 334878452864978819061930997065061937449464345411, 282119793273156214497433603026823910474682900640)
(h2, r2, s2) = (156467414524100313878421798396433081456201599833, 584114556699509111695337565541829205336940360354, 827371522240921066790477048569787834877112159142)
q = 829396411171540475587755762866203184101195238207

# 计算 a, b, c


PR.<x> = PolynomialRing(GF(q))
f = (r1*s2)*x^2 -(r2*s1)*x + (h1*r2)-(h2*r1)
hh=f.roots()
print(hh)
k = hh[1][0]
k1=k**2
x = (s1*k-h1)*inverse(r1,q)%q
print(n2s(int(x)))

#[(170464049350072111773451308890666207558293384951, 1), (9455554284687443083, 1)]
b'e = 44519'
```

然后破解p和q：
```python
from sympy.abc import x, y, t
from sympy.solvers.diophantine.diophantine import diop_quadratic
from Crypto.Util.number import isPrime


N = 179093209181929149953346613617854206675976823277412565868079070299728290913658

print('solving...')
solve = diop_quadratic(x**2 + y**2 - N, t)
print('solved')

for p, q in solve:
    p, q = int(p), int(q)
    if isPrime(p) and isPrime(q):
        print(p,q)
# 302951519846417861008714825074296492447 295488723650623654106370451762393175957
```

最后解密：
```python
import sympy
from libnum import *
from Crypto.Util.number import *
from gmpy2 import *
# 给定的值
c = 18947793008364154366082991046877977562448549186943043756326365751169362247521
p = 302951519846417861008714825074296492447
q = 295488723650623654106370451762393175957
e = 44519

# 计算 n
n = p * q

# 计算 phi(n)
phi_n = (p - 1) * (q - 1)
print(p**2+q**2)

# 找到 d
d = gmpy2.invert(e, phi_n)
print(d)

# 解密密文
m = pow(c, d, n)
print(long_to_bytes(m))
# b'D0g3xGC{EZ_DSA_@nd_C0mplex_QAQ}'
```
